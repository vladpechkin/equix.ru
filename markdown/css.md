# Варианты написания стилей

## TailwindCSS

В библиотеке EQUIX все стили написаны с помощью фреймворка TailwindCSS, поскольку на данном этапе проекту критически важна скорость разработки и производительность итоговых приложений. Однако, Tailwind неидеален.

Во-первых, он имеет повышенный порог входа - любой желающий разрабатывать с помощью EQUIX обязан знать не только CSS, но и синтаксис и имена классов Tailwind. Во-вторых, стили, написанные на Tailwind, плохо совместимы с кодом, написанном на обычном CSS. Например, в компонент, завязанный на Tailwind, нельзя просто скопировать и вставить обычный CSS код. Для этого придется модифицировать глобальную конфигурацию, что быстро приведет к запутанному коду. Да и в целом смешивание подходов нежелательно.

Поэтому рассмотрены альтернативы. Их можно сравнить и описать следующим образом:

1. TailwindCSS - хорошая производительность, хорошая скорость написания, плохая совместимость, высокий порог входа.
2. CSS-in-JS - плохая производительность, хорошая скорость написания, хорошая совместимость, низкий порог входа.
3. Linaria - хорошая производительность, хорошая скорость написания, хорошая совместимость, низкий порог входа.

## CSS-in-JS

В качестве имплементации подхода CSS-in-JS для EQUIX была разработана функция cssToStyle():

```
export const cssToStyle = (string: string) =>
  Object.fromEntries(
    string
      .replaceAll(": ", ":")
      .replaceAll("; ", ";")
      .split(";")
      .filter(Boolean)
      .map((str) => str.split(":"))
      .map((arr) => [arr[0].replace(/-./g, (m) => m.toUpperCase()[1]), arr[1]])
  );
```

Используя ее, можно писать стили на чистом CSS и передавать в проп style:

```
<div style={cssToStyle("color: red;")}>
```

...однако это чревато ухудшением производительности. Если вы не имеете желания или возможности изучать TailwindCSS, такой компромисс может быть предпочтителен - просто добавьте эту функцию в любое место приложения, импортируйте и вызывайте.

## Linaria

В будущем планируется переписать EQUIX целиком на Linaria - библиотеку, сочетающую простоту написания чистого CSS и производительность TailwindCSS. Но, во-первых, эта библиотека и некоторые связанные с ней утилиты на момент разработки EQUIX не готовы для использования в продакшне; во-вторых, это достаточно новый подход, так что переписывание EQUIX займет, вероятно, очень много времени из-за непредвиденных всплывающих проблем. Если вы хотите попробовать экспериментальный подход к написанию стилей, то следуйте инструкции ниже. В каждом блоке кода вверху указано название файла, а ниже - его содержимое. Убедитесь, что у вас существуют все указанные файлы и они включают в себя хотя бы это содержимое. После чего выполните `npm i` и можете писать стили, как в примерах `*.tsx` и `.linaria.global.tsx`.

```
// package.json
"dependencies": {
    "@callstack/react-theme-provider": "^3.0.9",
    "@linaria/babel-preset": "^5.0.4",
    "@linaria/core": "^6.1.0",
    "@linaria/react": "^6.1.0",
    "next": "14.1.4",
    "next-linaria": "^0.11.0",
    "next-with-linaria": "^0.7.0",
    "react": "^18",
    "react-dom": "^18"
}
```

```
// next.config.js
const withLinaria = require('next-with-linaria');

/** @type {import('next-with-linaria').LinariaConfig} */
const config = {};
module.exports = withLinaria(config);
```

```
// .babelrc
{
  "presets": ["next/babel", "@linaria"],
  "plugins": []
}
```

```
// *.tsx
import { css } from "@linaria/core";

<div
  className={css`
    color: red;
  `}
>
  text
</div>;
```

```
// app/.linaria.global.tsx
import { css } from '@linaria/core';

export const globals = css`
  :global() {
    @font-face {
      font-family: 'MaterialIcons';
      src: url(../assets/fonts/MaterialIcons.ttf) format('truetype');
    }
  }
`;
```

```
// app/layout.tsx
import './style.linaria.global';
```
